CLASS DESIGN

The classes I implemented were the CountryStorage.cpp class and its respective header file, CountryStorage.h. This class is responsible for managing a collection of time series data for a specific country, including storing, loading, and manipulating various time series.

ALTERNATIVES AND JUSTIFICATION 

My first alternative was adding the function “resize_double”, my justification behind adding this helper function was that I wanted to reuse the logic for resizing the dynamic arrays used for storing years and data. Initially, I considered directly including the resizing logic within both the “add” and “load” functions. However, this approach would cause significant code duplication, as the resizing logic would be in multiple functions. By creating the “resize_double” helper function, I ensured that the code remained clean and reusable. Additionally, if future changes to the resizing logic are required, they can be implemented in one place, rather than updating multiple functions.
My next alternative was inserting the new data from the add command directly into its correct position instead of appending it to the end of the array and then sorting the array. My justification behind this alternative was that continuously keeping the array sorted during each insertion is more efficient for the query-style system of the program. If the user were to enter a large number of queries, call this number m, then the runtime of m calls to the add command using the append and sort approach would be m * O(n log n), since the array would need to be sorted after every insertion. By directly inserting new data into its correct position, the runtime for my approach is reduced to m * O(n), as finding the correct position and shifting elements requires linear time. This makes my approach faster for handling large numbers of user queries efficiently.
My last alternative was my choice to use dynamic arrays instead of a linked list or hash maps as my primary data structure. My justification behind this alternative was that arrays provide a simpler way to manage time series data. With arrays, accessing elements by index is fast and requires no extra memory for pointers, making the implementation easier to work with. Since the dataset size grows in a predictable manner, resizing the array when needed is manageable. A linked list would introduce complexity, requiring additional memory for pointers and making traversal operations more difficult. By using arrays, I kept the code more readable for the specific needs of this project.

RUNTIME ANALYSIS

The runtime for my ADJACENT command is O(n*log(n)), where n is the number of countries adjacent to the given country. This is because I used a std::set to store each country’s adjacency list, which keeps everything sorted. The function first looks up the country in an unordered_map, which takes O(1) time complexity (since hash maps in C++ STL are constant time). Then, once I have the correct set of adjacent countries, I loop through the std::set, which takes O(n) time to iterate through. But since std::set is backed by a balanced tree, every comparison (like checking and printing string names) adds a log(n) factor. So overall, the total runtime ends up being O(n*log(n)). I based this analysis off how std::set works in the C++ STL, and confirmed it on cppreference.com, where it says insertions and lookups in a set take log(n) time.

