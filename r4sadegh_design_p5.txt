CLASS DESIGN

The classes I implemented were the CountryStorage.cpp class and its respective header file, CountryStorage.h. This class is responsible for managing a collection of time series data for a specific country, including storing, loading, and manipulating various time series.

ALTERNATIVES AND JUSTIFICATION 

My first alternative was adding the function “resize_double”, my justification behind adding this helper function was that I wanted to reuse the logic for resizing the dynamic arrays used for storing years and data. Initially, I considered directly including the resizing logic within both the “add” and “load” functions. However, this approach would cause significant code duplication, as the resizing logic would be in multiple functions. By creating the “resize_double” helper function, I ensured that the code remained clean and reusable. Additionally, if future changes to the resizing logic are required, they can be implemented in one place, rather than updating multiple functions.
My next alternative was inserting the new data from the add command directly into its correct position instead of appending it to the end of the array and then sorting the array. My justification behind this alternative was that continuously keeping the array sorted during each insertion is more efficient for the query-style system of the program. If the user were to enter a large number of queries, call this number m, then the runtime of m calls to the add command using the append and sort approach would be m * O(n log n), since the array would need to be sorted after every insertion. By directly inserting new data into its correct position, the runtime for my approach is reduced to m * O(n), as finding the correct position and shifting elements requires linear time. This makes my approach faster for handling large numbers of user queries efficiently.
My last alternative was my choice to use dynamic arrays instead of a linked list or hash maps as my primary data structure. My justification behind this alternative was that arrays provide a simpler way to manage time series data. With arrays, accessing elements by index is fast and requires no extra memory for pointers, making the implementation easier to work with. Since the dataset size grows in a predictable manner, resizing the array when needed is manageable. A linked list would introduce complexity, requiring additional memory for pointers and making traversal operations more difficult. By using arrays, I kept the code more readable for the specific needs of this project.

RUNTIME ANALYSIS

The runtime for my LOOKUP command (lookup() function) is O(1) in the average case and O(N) in the worst case, where N is the number of countries stored in the hash table. This is because the function uses double hashing, which allows for direct indexing into the hash table. In the average case, assuming a low number of collisions, the function performs constant-time access, O(1), by computing the primary and secondary hash values and immediately finding the country in the table. Since the number of probes remains small, the runtime remains O(1). However, in the worst case, if many collisions occur or if the hash table is almost full, the function may have to probe through multiple entries before finding an empty slot. In the worst scenario, all N slots could be checked before finding that the country is not present, causing a runtime of O(N).